using CairoMakie
using Oceananigans
using JLD2
using Printf
using Oceananigans.Units
using Makie.Colors
using Statistics
using OffsetArrays
using FFTW

function snap_Œ∂_xy(label, frac)

    # Set the two dimensional parameters
    H = 50    # Depth of mixed layer
    f = 1e-4  # Coriolis parameter

    filename_xy_top = "raw_data/" * label * "_BI_xy" * ".jld2"

    # Read in the first iteration. We do this to load the grid
    Œ∂_ic = FieldTimeSeries(filename_xy_top, "Œ∂‚ÇÉ", iterations = 0)

    # Load in co-ordinate arrays
    # We do this separately for each variable since Oceananigans uses a staggered grid
    x, y, z = nodes(Œ∂_ic)

    # Now, open the file with our data
    file = jldopen(filename_xy_top)

    iterations = parse.(Int, keys(file["timeseries/t"]))
    iterations_animated = iterations[Int64(round(length(iterations)*0.5)) : length(iterations)]
    iter = iterations_animated[Int(round(frac*length(iterations)))]

    # Set up observables for plotting that will update as the iteration number is updated
    Œ∂_xy = file["timeseries/Œ∂‚ÇÉ/$iter"][:,:,1]

    # Calculate the maximum relative vorticity and buoyancy flux to set the scale for the colourmap
    Œ∂_max = maximum(Œ∂_xy)
    Œ∂_max = minimum([Œ∂_max, 20f])

    # Create the plot, starting at t = 0
    # This will be updated as the observable iter is updated
    fig = Figure(resolution = (440, 440))
    #xtitle = Axis((fig[1,1]), ylabel = L"$y/\mathrm{km}$", yticks = ([], []))
    ax_Œ∂ = Axis(fig[1, 1], xlabel = L"$x/\mathrm{km}$", ylabel = L"$y/\mathrm{km}$", title = L"\zeta/f", aspect = 1)
    hm_Œ∂ = heatmap!(ax_Œ∂, x/1kilometer, y/1kilometer, Œ∂_xy/f; colormap = :coolwarm, colorrange = (-Œ∂_max/f, Œ∂_max/f));
    Colorbar(fig[1, 2], hm_Œ∂)

    resize_to_layout!(fig)
    
    ##############################################
    # SEE IF CAN CHANGE COLORS, ADD TIME COUNTER #
    ##############################################

    display(fig)
    save("pretty_things/" * "Œ∂-snap.pdf", fig)

end

function snap_b_xy(label, frac)

    # Set the two dimensional parameters
    H = 50    # Depth of mixed layer
    f = 1e-4  # Coriolis parameter

    filename_xy_top = "raw_data/" * label * "_BI_xy" * ".jld2"

    # Read in the first iteration. We do this to load the grid
    Œ∂_ic = FieldTimeSeries(filename_xy_top, "b", iterations = 0)

    # Load in co-ordinate arrays
    # We do this separately for each variable since Oceananigans uses a staggered grid
    x, y, z = nodes(Œ∂_ic)

    # Now, open the file with our data
    file = jldopen(filename_xy_top)

    iterations = parse.(Int, keys(file["timeseries/t"]))
    iterations_animated = iterations[Int64(round(length(iterations)*0.5)) : length(iterations)]
    iter = iterations_animated[Int(round(frac*length(iterations)))]

    # Set up observables for plotting that will update as the iteration number is updated
    Œ∂_xy = file["timeseries/b/$iter"][:,:,1]

    # Calculate the maximum relative vorticity and buoyancy flux to set the scale for the colourmap
    Œ∂_max = maximum(abs.(Œ∂_xy))

    # Create the plot, starting at t = 0
    # This will be updated as the observable iter is updated
    fig = Figure(resolution = (440, 440))
    #xtitle = Axis((fig[1,1]), ylabel = L"$y/\mathrm{km}$", yticks = ([], []))
    ax_Œ∂ = Axis(fig[1, 1], xlabel = L"$x/\mathrm{km}$", ylabel = L"$y/\mathrm{km}$", title = L"b", aspect = 1)
    hm_Œ∂ = heatmap!(ax_Œ∂, x/1kilometer, y/1kilometer, Œ∂_xy; colorrange = (-Œ∂_max, Œ∂_max));
    Colorbar(fig[1, 2], hm_Œ∂)

    resize_to_layout!(fig)
    
    ##############################################
    # SEE IF CAN CHANGE COLORS, ADD TIME COUNTER #
    ##############################################

    display(fig)
    save("pretty_things/" * "b-snap.pdf", fig)

end

function snap_Œ¥_xy(label, frac)

    # Set the two dimensional parameters
    H = 50    # Depth of mixed layer
    f = 1e-4  # Coriolis parameter

    filename_xy_top = "raw_data/" * label * "_BI_xy" * ".jld2"

    # Read in the first iteration. We do this to load the grid
    b_ic = FieldTimeSeries(filename_xy_top, "Œ¥", iterations = 0)

    # Load in co-ordinate arrays
    # We do this separately for each variable since Oceananigans uses a staggered grid
    x, y, z = nodes(b_ic)

    # Now, open the file with our data
    file = jldopen(filename_xy_top)

    iterations = parse.(Int, keys(file["timeseries/t"]))
    iterations_animated = iterations[Int64(round(length(iterations)*0.5)) : length(iterations)]
    iter = iterations_animated[Int(round(frac*length(iterations)))]

    # Set up observables for plotting that will update as the iteration number is updated
    Œ∂_xy = file["timeseries/Œ¥/$iter"][:,:,1]

    # Calculate the maximum relative vorticity and buoyancy flux to set the scale for the colourmap
    Œ∂_max = maximum(abs.(Œ∂_xy))
    Œ∂_max = minimum([Œ∂_max, 20f])

    # Create the plot, starting at t = 0
    # This will be updated as the observable iter is updated
    fig = Figure(resolution = (440, 440))
    #xtitle = Axis((fig[1,1]), ylabel = L"$y/\mathrm{km}$", yticks = ([], []))
    ax_Œ∂ = Axis(fig[1, 1], xlabel = L"$x/\mathrm{km}$", ylabel = L"$y/\mathrm{km}$", title = L"\delta/f", aspect = 1)
    hm_Œ∂ = heatmap!(ax_Œ∂, x/1kilometer, y/1kilometer, colormap = :coolwarm, Œ∂_xy/f; colorrange = (-Œ∂_max/f, Œ∂_max/f));
    Colorbar(fig[1, 2], hm_Œ∂)

    resize_to_layout!(fig)
    
    ##############################################
    # SEE IF CAN CHANGE COLORS, ADD TIME COUNTER #
    ##############################################

    display(fig)
    save("pretty_things/" * "Œ¥-snap.pdf", fig)

end

function gaussian_filter_2d(z, m_cut, n_cut)
    (M, N) = size(z)
    z_f = fft(z)
    for i in 1:M, j in 1:N
        m = minimum([mod(i-1,M), mod(1-i,M)])
        n = minimum([mod(j-1,N), mod(1-j,N)])
        z_f[i, j] *= exp(-(m^2/m_cut^2 + n^2/n_cut^2))
    end
    real(ifft(z_f))
end

function per(i,N)
    # For periodic arrays
    mod(i-1, N) + 1
end

function snap_fdetect(label, frac, ‚àáb_scale = 1e-7, L_scale = 8000)

    filename_xy_top = "raw_data/" * label * "_BI_xy" * ".jld2"

    # Read in the first iteration. We do this to load the grid
    b_ic = FieldTimeSeries(filename_xy_top, "b", iterations = 0)

    # Load in co-ordinate arrays
    # We do this separately for each variable since Oceananigans uses a staggered grid
    xb, yb, zb = nodes(b_ic)
    M = length(xb)
    N = length(yb)
    Œîx = xb[2] - xb[1]
    Œîy = yb[2] - yb[1]
    m_cut = Int(round((xb[2] - xb[1]) * M / L_scale))
    n_cut = Int(round((yb[2] - yb[1]) * N / L_scale))

    # Now, open the file with our data
    file = jldopen(filename_xy_top)
    iterations = parse.(Int, keys(file["timeseries/t"]))
    iterations_animated = iterations[Int64(round(length(iterations)*0.5)) : length(iterations)]
    iter = iterations_animated[Int(round(frac*length(iterations)))]

    frames = 1:length(iterations)
    front_highlight = OffsetArrays.no_offset_view(zeros(frames, M, N))
    front_diagnose = OffsetArrays.no_offset_view(zeros(frames, M, N))

    b_x = file["timeseries/b_x/$iter"][:, :, 1]
    b_y = file["timeseries/b_y/$iter"][:, :, 1]
    abs‚àáb = [(x < 1e-4 ? x : 0) for x in (b_x.^2 + b_y.^2) .^ 0.5]
    #‚àá¬≤b = [(b_x[per(i+1,M),j] - b_x[per(i-1,M),j])/2Œîx + (b_y[i,per(j+1,N)] - b_y[i,per(j-1,N)])/2Œîy for i in 1:M, j in 1:N]
    ‚àáb_filter = [(x > ‚àáb_scale ? 0 : 0) for x in abs‚àáb]
    #‚àá¬≤b_filter = [(x > 10 * ‚àáb_scale/L_scale ? 1 : 0) for x in ‚àá¬≤b]
    front_filter = ‚àáb_filter# .| ‚àá¬≤b_filter
    front_highlight = front_filter

    filt_abs‚àáb = gaussian_filter_2d(abs‚àáb, m_cut, n_cut)
    b_x_filt = gaussian_filter_2d(b_x, m_cut, n_cut)
    b_y_filt = gaussian_filter_2d(b_y, m_cut, n_cut)
    abs_filt‚àáb = (b_x_filt.^2 + b_y_filt.^2) .^ 0.5
    ùíª = abs_filt‚àáb ./ filt_abs‚àáb
    front_diagnose = ùíª .* front_filter

    fig = Figure(resolution = (440, 440))
    ax_‚àáb = Axis(fig[1, 1], xlabel = L"$x/\mathrm{km}$", ylabel = L"$y/\mathrm{km}$", title = L"\mathcal{F}", aspect = 1)
    hm = heatmap!(ax_‚àáb, xb/1kilometer, yb/1kilometer, front_diagnose; colorrange = (0, 1));
    Colorbar(fig[1, 2], hm)

    display(fig)
    save("pretty_things/" * "fedetect-snap.pdf", fig)
    
end